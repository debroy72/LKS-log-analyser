from datetime import datetime
import pandas as pd
import streamlit as st

from parsing_utils import build_counts, mask_mb


def mask_other_errors(df: pd.DataFrame):
    return (
        df["tag"].eq("**")
        | df["raw"].str.contains(r"\bException\b", na=False)
        | df["raw"].str.contains(r"\bError\b", na=False, case=False)
    )


def mask_uncategorized(df: pd.DataFrame):
    covered = mask_mb(df) | df["tag"].eq("LOAD_PLU") | df["tag"].eq("** UE") | mask_other_errors(df)
    return ~covered


def render_timestamp_filter(df: pd.DataFrame) -> pd.DataFrame:
    st.subheader("‚è±Ô∏è Optional Timestamp Range Filter")
    use_filter = st.checkbox(
        "Enable timestamp range filter",
        value=False,
        help="Uncheck to process the entire file",
    )

    if not use_filter:
        st.info("Timestamp filtering disabled ‚Äî showing full file.")
        return df

    min_ts = df["timestamp_dt"].min()
    max_ts = df["timestamp_dt"].max()
    if pd.isna(min_ts) or pd.isna(max_ts):
        st.warning("Timestamps could not be parsed; showing all records.")
        return df

    col1, col2 = st.columns(2)
    with col1:
        start_date = st.date_input("Start date", value=min_ts.date())
        start_time = st.time_input("Start time", value=min_ts.time())
    with col2:
        end_date = st.date_input("End date", value=max_ts.date())
        end_time = st.time_input("End time", value=max_ts.time())

    start = datetime.combine(start_date, start_time)
    end = datetime.combine(end_date, end_time)

    filtered = df[(df["timestamp_dt"] >= pd.to_datetime(start)) & (df["timestamp_dt"] <= pd.to_datetime(end))]
    st.success(f"Filtered to {len(filtered)} records between {start} and {end}.")
    return filtered


def render_paw_filter(df: pd.DataFrame) -> pd.DataFrame:
    st.subheader("ü™ü PAW Log Filter")
    paw_only = st.checkbox(
        "Show only PAW (LogS) entries",
        value=False,
        help="Filters to entries generated by the PAW LogS driver or rows that contain an inner PAW timestamp.",
    )

    if not paw_only:
        return df

    driver_mask = df["driver_name"].fillna("").str.contains("logs", case=False)
    paw_ts_mask = df["PAW timestamp"].fillna("").astype(str).str.strip().ne("")
    paw_mask = driver_mask | paw_ts_mask
    total_before = len(df)
    filtered = df[paw_mask].copy()
    if filtered.empty:
        st.warning("No PAW entries detected in the current selection.")
    else:
        st.success(f"Showing {len(filtered)} PAW entries out of {total_before} total rows.")
    return filtered


def render_summary(df: pd.DataFrame):
    st.subheader("Summary")
    counts = build_counts(df)
    st.dataframe(pd.DataFrame([counts]), use_container_width=True)


def render_drilldowns(df: pd.DataFrame):
    st.subheader("üìä Explore Specific Sections")
    option = st.radio(
        "Select what to inspect:",
        ["None", "MB Messages", "PLU Loads", "Unhandled Exceptions (** UE)", "Other Errors", "Uncategorized Logs"],
        horizontal=True,
    )

    if option == "MB Messages":
        render_mb_messages(df)
    elif option == "PLU Loads":
        render_plu_loads(df)
    elif option == "Unhandled Exceptions (** UE)":
        render_unhandled_exceptions(df)
    elif option == "Other Errors":
        render_other_errors(df)
    elif option == "Uncategorized Logs":
        render_uncategorized(df)


def render_mb_messages(df: pd.DataFrame):
    st.markdown("### üí¨ MB Messages")
    mb_df = df[mask_mb(df)].copy()
    if mb_df.empty:
        st.info("No MB messages found.")
        return
    st.dataframe(mb_df[["line_no", "timestamp", "message", "raw"]], use_container_width=True, hide_index=True)
    st.download_button(
        "Download MB Messages (CSV)",
        mb_df.to_csv(index=False).encode("utf-8"),
        file_name="lks_mb_messages.csv",
    )


def render_plu_loads(df: pd.DataFrame):
    st.markdown("### üì¶ PLU Load Events")
    plu_df = df[df["tag"] == "LOAD_PLU"].copy()
    if plu_df.empty:
        st.info("No PLU load events found.")
        return
    st.dataframe(plu_df[["line_no", "timestamp", "message", "raw"]], use_container_width=True, hide_index=True)
    st.download_button(
        "Download PLU Loads (CSV)",
        plu_df.to_csv(index=False).encode("utf-8"),
        file_name="lks_plu_loads.csv",
    )


def render_unhandled_exceptions(df: pd.DataFrame):
    st.markdown("### ‚ö†Ô∏è Unhandled Exceptions (** UE)")
    ue_df = df[df["tag"] == "** UE"].copy()
    if ue_df.empty:
        st.info("No unhandled exceptions found.")
        return
    st.dataframe(ue_df[["line_no", "timestamp", "message", "raw"]], use_container_width=True, hide_index=True)
    st.download_button(
        "Download Unhandled Exceptions (CSV)",
        ue_df.to_csv(index=False).encode("utf-8"),
        file_name="lks_unhandled_exceptions.csv",
    )


def render_other_errors(df: pd.DataFrame):
    st.markdown("### ‚ùó Other Errors / Exceptions")
    err_mask = mask_other_errors(df)
    other_df = df[err_mask].copy()
    if other_df.empty:
        st.info("No other error entries found.")
        return
    st.dataframe(
        other_df[["line_no", "timestamp", "tag", "message", "raw"]],
        use_container_width=True,
        hide_index=True,
    )
    st.download_button(
        "Download Other Errors (CSV)",
        other_df.to_csv(index=False).encode("utf-8"),
        file_name="lks_other_errors.csv",
    )


def render_uncategorized(df: pd.DataFrame):
    st.markdown("### üóÇÔ∏è Uncategorized Logs")
    uncategorized_df = df[mask_uncategorized(df)].copy()
    if uncategorized_df.empty:
        st.info("Every entry is categorized by the views above.")
        return
    st.dataframe(
        uncategorized_df[["line_no", "timestamp", "tag", "description", "message", "raw"]],
        use_container_width=True,
        hide_index=True,
    )
    st.download_button(
        "Download uncategorized logs (CSV)",
        uncategorized_df.to_csv(index=False).encode("utf-8"),
        file_name="lks_uncategorized_logs.csv",
    )


def render_error_details(df: pd.DataFrame):
    st.subheader("Error / Exception Details")
    err_mask = (
        df["raw"].str.contains(r"\*\*\s*UE", na=False)
        | df["tag"].eq("**")
        | df["raw"].str.contains(r"\bException\b", na=False)
        | df["raw"].str.contains(r"\bError\b", na=False, case=False)
        | df["raw"].str.contains(r"\bNT_F\b", na=False)
        | df["raw"].str.contains(r"Etikett oder Spalt zu lang", na=False)
        | df["raw"].str.contains(r"Druckleiste ist abgehoben", na=False)
    )
    edf = df.loc[err_mask, ["line_no", "timestamp", "tag", "description", "message", "raw"]].copy()
    st.dataframe(edf, use_container_width=True)


def render_full_log(df: pd.DataFrame):
    st.subheader("Full Parsed Log")
    st.dataframe(df.head(1000), use_container_width=True)
    st.download_button(
        "Download full parsed log (CSV)",
        df.to_csv(index=False).encode("utf-8"),
        file_name="lks_full_log.csv",
    )
